# Модель безопасности
### В этом модуле безопасность организована на основе Role Based модели
![alt text](https://i.imgur.com/3AEgAcp.jpeg)
### Все таблицы описаны в liquibase change-set-ах
### В данный момент всего существует 8 authorities
1. read_event
2. create_event
3. update_event
4. remove_event
5. read_place
6. create_place
7. update_place
8. remove_place
### В данный момент всего существует 2 roles, в скобках указаны соответствующие authorities
1. USER (1, 5)
2. ADMIN (1, 2, 3, 4, 5, 6, 7, 8)

# Запуск приложения
### Для корректного запуска приложения нужно: 
* В application.properties настроить подключение с базой данных 
* Настроить данные для ADMIN пользователя, сделать это можно несколькими способами:
    * В переменные окружения добавить: 
      * ADMIN_EMAIL 
      * ADMIN_USERNAME
      * ADMIN_PASSWORD(должен быть изначально закодирован с помощью алгоритма BCrypt с мощностью 7, сделать это можно на [этом сайте](https://bcrypt.online))
    * В файл application properties добавить три строчки: 
      * spring.liquibase.parameters.ADMIN_EMAIL=example@mail.ru 
      * spring.liquibase.parameters.ADMIN_USERNAME=Example123 
      * spring.liquibase.parameters.ADMIN_PASSWORD=(также должен быть закодирован)

# Использование приложения
### Для регистрации нужно использовать endpoint: /api/v1/auth/register 
* Endpoint доступен без авторизации, на него нужно отправить payload описанный в классе NewUserPayload
* Имя пользователя и почта должны быть уникальны, поэтому этот endpoint может вернуть bad request в обратном случае или в случае неправильного payload формата 
* Пароль должен состоять из букв латинского алфавита и цифр, обязательно должен содержать хотя бы одну букву и хотя бы одну цифру, длина пароля минимум 8
* Имя пользователя должно состоять из букв латинского алфавита и цифр, обязательно должно содержать хотя бы одну букву
* При регистрации пользователю по умолчанию присваивается роль USER
* В случае успешной регистрации возвращается код 200 и json с пользователем без пароля

### Для авторизации нужно использовать endpoint: /api/v1/auth/login
* Endpoint доступен без авторизации, на него нужно отправить payload описанный в классе LoginPayload
* В случае успешной авторизации возвращается код 200 и json с JWT токеном, который будет использоваться для доступа к защищенным ресурсам
  * Токен действует согласно переменной в application.properties jwt.token.expiryDate.remember если параметр rememberMe=true by default 30 days
  * Токен действует согласно переменной в application.properties jwt.token.expiryDate.notRemember если параметр rememberMe=false by default 10 minutes
* В случае неуспешной авторизации возвращается код 401 и json с ошибкой
* Токен возвращаемый этим endpoint-ом нужно будет использовать для любого защищенного endpoint-а в header: Authorization Bearer {token}

### Для логаута нужно использовать endpoint: /api/v1/auth/logout
* Endpoint доступен только авторизованным пользователям т.е. у тех у кого в запросе есть заголовок Authorization Bearer {JWT token}
* После запроса на этот endpoint token добавляется в черный список, и при каждом следующем обращении к защищенному ресурсу доступ будет отклонён
* Чёрный список храниться в памяти и каждые 10 минут очищается от уже истёкших токенов

### Для сброса пароля нужно использовать endpoint: /api/v1/auth/reset-password
* Endpoint доступен без авторизации, на него нужно отправить payload описанный в классе ResetPasswordPayload
* После запроса на указанный email должен быть выслан jwt токен для входа, чтобы поменять пароль
* Этот jwt токен будет действителен в течение времени указанного в конфигурации application.properties jwt.token.expiryDate.reset by default 3 minutes
* Так как взаимодействие с почтой не настроено, то пока этот токен просто выводится в лог
* Если указанной почты не существует, возвращается код 404

### Для изменения данных пользователя нужно использовать endpoint: /api/v1/auth/change-user
* Endpoint доступен только авторизованным пользователям т.е. у тех у кого в запросе есть заголовок Authorization Bearer {JWT token}
* Endpoint также доступен по reset token-у, высланному на почту при смене пароля
* На endpoint нужно отправить payload описанный в классе UpdateUserPayload
* Username поменять нельзя
* Почту можно поменять только на ту, которая еще не существует у другого пользователя, иначе вернётся код 400
* На пароль также распространяются такие же правила как при регистрации


